// Copyright 2024 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

use crate::{
    cashnotes::{CashNoteBuilder, Output, UnsignedTransfer},
    rng, CashNote, DerivationIndex, DerivedSecretKey, Input, MainPubkey, MainSecretKey, NanoTokens,
    Result, SignedSpend, SpendReason, Transaction, TransactionBuilder, TransferError, UniquePubkey,
};

use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, BTreeSet};

/// List of CashNotes, with (optionally when needed) their corresponding derived owning secret key.
pub type CashNotesAndSecretKey = Vec<(CashNote, Option<DerivedSecretKey>)>;

/// Offline Transfer
/// This struct contains all the necessary information to carry out the transfer.
/// The created cash_notes and change cash_note from a transfer
/// of tokens from one or more cash_notes, into one or more new cash_notes.
#[derive(custom_debug::Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct OfflineTransfer {
    /// The cash_notes that were created containing
    /// the tokens sent to respective recipient.
    #[debug(skip)]
    pub cash_notes_for_recipient: Vec<CashNote>,
    /// The cash_note holding surplus tokens after
    /// spending the necessary input cash_notes.
    #[debug(skip)]
    pub change_cash_note: Option<CashNote>,
    /// The parameters necessary to send all spend requests to the network.
    pub all_spend_requests: Vec<SignedSpend>,
}

impl OfflineTransfer {
    pub fn build_transaction(&self) -> Transaction {
        let mut inputs = vec![];
        let mut outputs = vec![];

        for cn in self.cash_notes_for_recipient.iter() {
            let mut amount = 0;
            for parent_spend in cn.parent_spends.iter() {
                if let Some(a) = parent_spend.spend.get_output_amount(&cn.unique_pubkey()) {
                    amount += a.as_nano();
                    inputs.push(Input::new(*parent_spend.unique_pubkey(), a.as_nano()));
                }
            }
            outputs.push(Output::new(cn.unique_pubkey(), amount));
        }

        if let Some(ref cn) = self.change_cash_note {
            let mut amount = 0;
            for parent_spend in cn.parent_spends.iter() {
                if let Some(a) = parent_spend.spend.get_output_amount(&cn.unique_pubkey()) {
                    amount += a.as_nano();
                    inputs.push(Input::new(*parent_spend.unique_pubkey(), a.as_nano()));
                }
            }
            outputs.push(Output::new(cn.unique_pubkey(), amount));
        }

        Transaction { inputs, outputs }
    }

    pub fn from_transaction(
        signed_spends: BTreeSet<SignedSpend>,
        change_id: UniquePubkey,
        output_details: BTreeMap<UniquePubkey, (MainPubkey, DerivationIndex, NanoTokens)>,
    ) -> Result<Self> {
        let cash_note_builder = CashNoteBuilder::new(output_details, signed_spends.clone());

        // Perform validations of input tx and signed spends,
        // as well as building the output CashNotes.
        let mut created_cash_notes: Vec<_> = cash_note_builder
            .build()?
            .into_iter()
            .map(|(cash_note, _)| cash_note)
            .collect();

        let mut change_cash_note = None;
        created_cash_notes.retain(|created| {
            if created.unique_pubkey() == change_id {
                change_cash_note = Some(created.clone());
                false
            } else {
                true
            }
        });

        Ok(Self {
            cash_notes_for_recipient: created_cash_notes,
            change_cash_note,
            all_spend_requests: signed_spends.into_iter().collect(),
        })
    }

    /// A function for creating an offline transfer of tokens.
    /// This is done by creating new cash_notes to the recipients (and a change cash_note if any)
    /// by selecting from the available input cash_notes, and creating the necessary
    /// spends to do so.
    ///
    /// Those signed spends are found in each new cash_note, and must be uploaded to the network
    /// for the transaction to take effect.
    /// The peers will validate each signed spend they receive, before accepting it.
    /// Once enough peers have accepted all the spends of the transaction, and serve
    /// them upon request, the transaction will be completed.
    ///
    /// When there are multiple inputs from different unique_pubkeys,
    /// they shall all be paid into a `middle_addr` first, then from that `middle_addr` pay out
    /// to recipients as normal.
    pub fn new(
        available_cash_notes: CashNotesAndSecretKey,
        recipients: Vec<(NanoTokens, MainPubkey, DerivationIndex)>,
        change_to: MainPubkey,
        input_reason_hash: SpendReason,
        middle_addr: Option<(MainPubkey, DerivationIndex, DerivedSecretKey)>,
    ) -> Result<Self> {
        let total_output_amount = recipients
            .iter()
            .try_fold(NanoTokens::zero(), |total, (amount, _, _)| {
                total.checked_add(*amount)
            })
            .ok_or_else(|| {
                TransferError::CashNoteReissueFailed(
                    "Overflow occurred while summing the amounts for the recipients.".to_string(),
                )
            })?;

        // We need to select the necessary number of cash_notes from those that we were passed.
        let (cash_notes_to_spend, change_amount) =
            select_inputs(available_cash_notes, total_output_amount)?;

        let selected_inputs = TransferInputs {
            cash_notes_to_spend,
            recipients,
            change: (change_amount, change_to),
        };

        create_offline_transfer_with(selected_inputs, input_reason_hash, middle_addr)
    }

    pub fn verify(&self, main_key: &MainSecretKey) -> Result<()> {
        for cn in self.cash_notes_for_recipient.iter() {
            cn.verify(main_key)?;
        }
        if let Some(ref cn) = self.change_cash_note {
            cn.verify(main_key)?;
        }
        Ok(())
    }
}

/// The input details necessary to
/// carry out a transfer of tokens.
#[derive(Debug)]
struct TransferInputs {
    /// The selected cash_notes to spend, with the necessary amounts contained
    /// to transfer the below specified amount of tokens to each recipients.
    pub cash_notes_to_spend: CashNotesAndSecretKey,
    /// The amounts and cash_note ids for the cash_notes that will be created to hold the transferred tokens.
    pub recipients: Vec<(NanoTokens, MainPubkey, DerivationIndex)>,
    /// Any surplus amount after spending the necessary input cash_notes.
    pub change: (NanoTokens, MainPubkey),
}

/// A function for creating an unsigned transfer of tokens.
pub fn create_unsigned_transfer(
    available_cash_notes: CashNotesAndSecretKey,
    recipients: Vec<(NanoTokens, MainPubkey, DerivationIndex)>,
    change_to: MainPubkey,
    reason_hash: SpendReason,
) -> Result<UnsignedTransfer> {
    let total_output_amount = recipients
        .iter()
        .try_fold(NanoTokens::zero(), |total, (amount, _, _)| {
            total.checked_add(*amount)
        })
        .ok_or(TransferError::ExcessiveNanoValue)?;

    // We need to select the necessary number of cash_notes from those that we were passed.
    let (cash_notes_to_spend, change_amount) =
        select_inputs(available_cash_notes, total_output_amount)?;

    let selected_inputs = TransferInputs {
        cash_notes_to_spend,
        recipients,
        change: (change_amount, change_to),
    };

    let (tx_builder, change_id) = create_transaction_builder_with(selected_inputs)?;

    // Get the unsigned Spends.
    tx_builder.build_unsigned_transfer(reason_hash, change_id)
}

/// Select the necessary number of cash_notes from those that we were passed.
fn select_inputs(
    available_cash_notes: CashNotesAndSecretKey,
    total_output_amount: NanoTokens,
) -> Result<(CashNotesAndSecretKey, NanoTokens)> {
    let mut cash_notes_to_spend = Vec::new();
    let mut total_input_amount = NanoTokens::zero();
    let mut change_amount = total_output_amount;

    for (cash_note, derived_key) in available_cash_notes {
        let input_key = cash_note.unique_pubkey();

        let cash_note_balance = match cash_note.value() {
            Ok(token) => token,
            Err(err) => {
                warn!(
                    "Ignoring input CashNote (id: {input_key:?}) due to missing an output: {err:?}"
                );
                continue;
            }
        };

        // Add this CashNote as input to be spent.
        cash_notes_to_spend.push((cash_note, derived_key));

        // Input amount increases with the amount of the cash_note.
        total_input_amount = total_input_amount.checked_add(cash_note_balance)
            .ok_or_else(|| {
                TransferError::CashNoteReissueFailed(
                    "Overflow occurred while increasing total input amount while trying to cover the output CashNotes."
                    .to_string(),
            )
            })?;

        // If we've already combined input CashNotes for the total output amount, then stop.
        match change_amount.checked_sub(cash_note_balance) {
            Some(pending_output) => {
                change_amount = pending_output;
                if change_amount.as_nano() == 0 {
                    break;
                }
            }
            None => {
                change_amount =
                    NanoTokens::from(cash_note_balance.as_nano() - change_amount.as_nano());
                break;
            }
        }
    }

    // Make sure total input amount gathered with input CashNotes are enough for the output amount
    if total_output_amount > total_input_amount {
        return Err(TransferError::NotEnoughBalance(
            total_input_amount,
            total_output_amount,
        ));
    }

    Ok((cash_notes_to_spend, change_amount))
}

fn create_transaction_builder_with(
    selected_inputs: TransferInputs,
) -> Result<(TransactionBuilder, crate::UniquePubkey)> {
    let TransferInputs {
        change: (change, change_to),
        ..
    } = selected_inputs;

    let mut inputs = vec![];
    for (cash_note, derived_key) in selected_inputs.cash_notes_to_spend {
        let token = match cash_note.value() {
            Ok(token) => token,
            Err(err) => {
                warn!("Ignoring cash_note, as it didn't have the correct derived key: {err}");
                continue;
            }
        };

        let input = Input {
            unique_pubkey: cash_note.unique_pubkey(),
            amount: token,
        };

        let mut parent_spends = BTreeSet::new();
        for spend in cash_note.parent_spends.iter() {
            let _ = parent_spends.insert(*spend.unique_pubkey());
        }

        inputs.push((
            input,
            derived_key,
            cash_note.derivation_index,
            parent_spends,
        ));
    }

    // Build the transaction and create change cash_note if needed
    let mut tx_builder = TransactionBuilder::default()
        .add_inputs(inputs)
        .add_outputs(selected_inputs.recipients);
    let mut rng = rng::thread_rng();
    let derivation_index = DerivationIndex::random(&mut rng);
    let change_id = change_to.new_unique_pubkey(&derivation_index);
    if !change.is_zero() {
        tx_builder = tx_builder.add_output(change, change_to, derivation_index);
    }

    Ok((tx_builder, change_id))
}

/// The tokens of the input cash_notes will be transfered to the
/// new cash_notes (and a change cash_note if any), which are returned from this function.
/// This does not register the transaction in the network.
/// To do that, the `signed_spends` of each new cash_note, has to be uploaded
/// to the network. When those same signed spends can be retrieved from
/// enough peers in the network, the transaction will be completed.
fn create_offline_transfer_with(
    mut selected_inputs: TransferInputs,
    input_reason: SpendReason,
    middle_addr: Option<(MainPubkey, DerivationIndex, DerivedSecretKey)>,
) -> Result<OfflineTransfer> {
    let mut all_spend_requests = vec![];

    let input_keys: BTreeSet<_> = selected_inputs
        .cash_notes_to_spend
        .iter()
        .map(|(cn, _)| cn.unique_pubkey)
        .collect();
    if input_keys.len() > 1 {
        info!(
            "Multiple input_keys vs multiple outputs detected {:?}",
            input_keys
        );
        if let Some((main_pubkey, derivation_index, middle_derived_sk)) = middle_addr {
            let mut middle_cash_notes = vec![];
            for input_key in input_keys {
                let mut amount: u64 = 0;
                let cash_notes_to_spend = selected_inputs
                    .cash_notes_to_spend
                    .iter()
                    .filter_map(|(cn, derived_sk)| {
                        if cn.unique_pubkey == input_key {
                            if let Ok(value) = cn.value() {
                                amount += value.as_nano();
                                Some((cn.clone(), derived_sk.clone()))
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    })
                    .collect();

                let recipients = vec![(NanoTokens::from(amount), main_pubkey, derivation_index)];

                let middle_inputs = TransferInputs {
                    cash_notes_to_spend,
                    recipients,
                    change: (NanoTokens::zero(), selected_inputs.change.1),
                };

                let (tx_builder, _change_id) = create_transaction_builder_with(middle_inputs)?;
                let cash_note_builder = tx_builder.build(input_reason.clone());
                let signed_spends: BTreeMap<_, _> = cash_note_builder
                    .signed_spends()
                    .into_iter()
                    .map(|spend| (spend.unique_pubkey(), spend))
                    .collect();

                for (_, signed_spend) in signed_spends.into_iter() {
                    all_spend_requests.push(signed_spend.to_owned());
                }
                middle_cash_notes.extend(
                    cash_note_builder
                        .build()?
                        .into_iter()
                        .map(|(cash_note, _)| cash_note)
                        .collect::<Vec<_>>(),
                );
            }

            info!("We now have middle cash notes: {middle_cash_notes:?}");

            let mut parent_spends = BTreeSet::new();
            for cn in middle_cash_notes.iter() {
                for parent_spend in cn.parent_spends.iter() {
                    let _ = parent_spends.insert(parent_spend.clone());
                }
            }

            let cash_notes_to_spend = if let Some(cn) = middle_cash_notes.first() {
                let merged_cn = CashNote {
                    unique_pubkey: cn.unique_pubkey,
                    parent_spends,
                    main_pubkey: cn.main_pubkey,
                    derivation_index: cn.derivation_index,
                };
                info!("We now have a merged cash note: {merged_cn:?}");
                vec![(merged_cn, Some(middle_derived_sk.clone()))]
            } else {
                return Err(TransferError::MultipleInputsWithoutMiddlePayment);
            };

            selected_inputs = TransferInputs {
                cash_notes_to_spend,
                recipients: selected_inputs.recipients,
                change: selected_inputs.change,
            };
        } else {
            return Err(TransferError::MultipleInputsWithoutMiddleAddr);
        }
    }

    let (tx_builder, change_id) = create_transaction_builder_with(selected_inputs)?;

    // Finalize the tx builder to get the cash_note builder.
    let cash_note_builder = tx_builder.build(input_reason);

    let signed_spends: BTreeMap<_, _> = cash_note_builder
        .signed_spends()
        .into_iter()
        .map(|spend| (spend.unique_pubkey(), spend))
        .collect();

    for (_, signed_spend) in signed_spends.into_iter() {
        all_spend_requests.push(signed_spend.to_owned());
    }

    let mut created_cash_notes: Vec<_> = cash_note_builder
        .build()?
        .into_iter()
        .map(|(cash_note, _)| cash_note)
        .collect();

    let mut change_cash_note = None;
    created_cash_notes.retain(|created| {
        if created.unique_pubkey() == change_id {
            change_cash_note = Some(created.clone());
            false
        } else {
            true
        }
    });

    Ok(OfflineTransfer {
        cash_notes_for_recipient: created_cash_notes,
        change_cash_note,
        all_spend_requests,
    })
}
